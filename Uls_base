#include<stdio.h> 
 #include<string.h> 
 #include<stdlib.h> 
 #include <sys/types.h> 
 #include <dirent.h> 
 #include <sys/stat.h> 
 #include <unistd.h> 
 #include <fcntl.h> 
 #include <sys/ioctl.h> 
#include <pwd.h>
#include <stdbool.h>
#include <endian.h>
#include <errno.h>
#include <stdint.h>
#include <pwd.h> 
#include <grp.h> 
#include <time.h> 



char * mx_getenv (const char *name)
{
  size_t len = strlen (name);
  char **ep;
  uint16_t name_start;
  if (__environ == NULL || name[0] == '\0')
    return NULL;
  if (name[1] == '\0')
    {
      /* The name of the variable consists of only one character.  Therefore
         the first two characters of the environment entry are this character
         and a '=' character.  */
#if __BYTE_ORDER == __LITTLE_ENDIAN || !_STRING_ARCH_unaligned
      name_start = ('=' << 8) | *(const unsigned char *) name;
#else
      name_start = '=' | ((*(const unsigned char *) name) << 8);
#endif
      for (ep = __environ; *ep != NULL; ++ep)
        {
#if _STRING_ARCH_unaligned
          uint16_t ep_start = *(uint16_t *) *ep;
#else
          uint16_t ep_start = (((unsigned char *) *ep)[0]
                               | (((unsigned char *) *ep)[1] << 8));
#endif
          if (name_start == ep_start)
            return &(*ep)[2];
        }
    }
  else
    {
#if _STRING_ARCH_unaligned
      name_start = *(const uint16_t *) name;
#else
      name_start = (((const unsigned char *) name)[0]
                    | (((const unsigned char *) name)[1] << 8));
#endif
      len -= 2;
      name += 2;
      for (ep = __environ; *ep != NULL; ++ep)
        {
#if _STRING_ARCH_unaligned
          uint16_t ep_start = *(uint16_t *) *ep;
#else
          uint16_t ep_start = (((unsigned char *) *ep)[0]
                               | (((unsigned char *) *ep)[1] << 8));
#endif
          if (name_start == ep_start && !strncmp (*ep + 2, name, len)
              && (*ep)[len + 2] == '=')
            return &(*ep)[len + 3];
        }
    }
  return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool file_exist (char *name) {
    struct stat buf;
    return (stat (name, &buf) == 0);    
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int mx_flag_l(void) {
   char *curr_dir = NULL; 
   DIR *dp = NULL; 
   struct dirent *dptr = NULL; 
   unsigned int count = 0; 
   long *ptr = NULL; 
   struct winsize w; 
 
   //to get the number of rows and column visible on terminal 
   ioctl(STDOUT_FILENO, TIOCGWINSZ, &w); 
 
   // Fetch the environment variable PWD so as to get the  
   // Current working directory 
   curr_dir = mx_getenv("PWD"); 
   if (NULL == curr_dir) 
   { 
       perror("\n ERROR : Could not get the working directory\n"); 
       return -1; 
   } 
 
   // Variable to hold number of files inside the directory 
   int num_files = 0; 
   // opne the directory 
   dp = opendir((const char*)curr_dir);   
   // Start reading the directory contents 
   while(NULL != (dptr = readdir(dp)))  
   { 
       // Do not count the files beginning with '.' 
       if(dptr->d_name[0] != '.') 
       num_files++; 
   } 
   // Our aim was to count the number of files/folders  
   // inside the current working directory. Since its  
   // done so close the directory. 
   closedir(dp); 
 
   // Restore the values back as we will be using them 
   // later again 
   dp = NULL; 
   dptr = NULL; 
 
   // Check that we should have at least one file/folder 
   // inside the current working directory 
   if(!num_files) 
   { 
       return 0; 
   } 
   else 
   { 
       // Allocate memory to hold the addresses of the  
       // names of contents in current working directory 
       ptr = malloc(num_files*8); 
       if(NULL == ptr) 
       { 
           perror("\n Memory allocation failed\n"); 
           return -1; 
       } 
       else 
       { 
           // Initialize the memory by zeros 
           memset(ptr,0,num_files*8); 
       } 
   }  
 
   // Open the directory again 
   dp = opendir((const char*)curr_dir);    
   if(NULL == dp) 
   { 
       perror("\n ERROR : Could not open the working directory\n"); 
       free(ptr); 
       return -1; 
   } 
  
   // Start iterating the directory and read all its contents 
   // inside an array allocated above. 
   unsigned int j = 0; 
   for(count = 0; NULL != (dptr = readdir(dp)); count++) 
   { 
       if(dptr->d_name[0] != '.') 
       { 
          ptr[j] = (long)dptr->d_name; 
          j++;  
       } 
   } 
 
   // Start sorting the names alphabetically 
   // Using bubble sorting here 
   for(count = 0; count< num_files-1;count++) 
   { 
       for(j=count+1; j< (num_files);j++) 
       { 
           char *c = (char*)ptr[count]; 
           char *d = (char*)ptr[j]; 
            
           // Check that the two characters should be from same set 
           if( ((*c >= 65) && (*d >= 65)) || ((*c <= 122) && (*d <= 122)) ) 
           { 
               int i = 0; 
               // If initial characters are same, continue comparing 
               // the characters until a difference is found 
               if(*c == *d) 
               { 
                   while(*(c+i)==*(d+i)) 
                   { 
                       i++; 
                   } 
               } 
               // Check if the earlier stored value is alphabetically 
               // higher than the next value 
               if(*(c+i) > *(d+i)) 
               { 
                   // If yes, then swap the values 
                   long temp = 0; 
                   temp = ptr[count]; 
                   ptr[count] = ptr[j]; 
                   ptr[j] = temp; 
               } 
 
           } 
           else 
           { 
               // if the two beginning characters are not from 
               // the same ascii set then make them same and then 
               // compare. 
               int off_1 = 0, off_2 = 0; 
               if(*c <= 90) 
               { 
                   off_1 = 32; 
               } 
               if(*d <= 90) 
               { 
                   off_2 = 32; 
               } 
 
               int i = 0; 
               // After the character set are made same, check if the 
               // beginning characters are same. If yes, then continue  
               // searching until we find some difference. 
               if(*c+ off_1 == *d + off_2) 
               { 
                   while(*(c+off_1+i)==*(d+off_2+i)) 
                   { 
                       i++; 
                   } 
               } 
               // After difference is found, check if a swap is required. 
               if((*c + off_1+i) > (*d + off_2+i)) 
               { 
                   // If yes, go ahead and do the swap 
                   long temp = 0; 
                   temp = ptr[count]; 
                   ptr[count] = ptr[j]; 
                   ptr[j] = temp; 
               } 
           } 
       } 
    } 
 
   // Now the names are sorted alphabetically 
   // Start displaying on console. 
   for(count = 0; count < num_files; count++) 
   { 
       int fd = -1; 
       struct stat st; 
 
       fd = open((char*)ptr[count], O_RDONLY, 0); 
       if(-1 == fd) 
       { 
           printf("\n Opening file/Directory failed\n"); 
           free(ptr); 
           return -1; 
       } 
 
      // Call fstat to get the stat info about the file 
      if(fstat(fd, &st)) 
      { 
          // If fstat() fails 
          printf("\n Fstat() failed\n"); 
          close(fd); 
          free(ptr); 
          return -1; 
      } 
 
      // Check if a directory 
      if(S_ISDIR(st.st_mode)) 
      { 
      printf("d"); 
      } 
      else 
      {     
          printf("-"); 
      } 
 
      // Check the owner permission 
      mode_t permission = st.st_mode & S_IRWXU; 
 
      if(permission & S_IRUSR) 
      { 
          printf("r"); 
      } 
      else 
      { 
          printf("-"); 
      } 
 
      if(permission & S_IWUSR) 
      { 
          printf("w"); 
      } 
      else 
      { 
          printf("-"); 
      } 
 
      if(permission & S_IXUSR) 
      { 
          printf("x"); 
      } 
      else 
      { 
          printf("-"); 
      } 
 
 
      // CHeck the group permission 
      permission = st.st_mode & S_IRWXG; 
 
      if(permission & S_IRGRP) 
      { 
          printf("r"); 
      } 
      else 
      { 
          printf("-"); 
      } 
 
      if(permission & S_IWGRP) 
      { 
          printf("w"); 
      } 
      else 
      { 
          printf("-"); 
      } 
 
      if(permission & S_IXGRP) 
      { 
          printf("x"); 
      } 
      else 
      { 
          printf("-"); 
      } 
 
 
      // CHeck other's permission 
      permission = st.st_mode & S_IRWXO; 
 
      if(permission & S_IROTH) 
      { 
          printf("r"); 
      } 
      else 
      { 
          printf("-"); 
      } 
 
      if(permission & S_IWOTH) 
      { 
          printf("w"); 
      } 
      else 
      { 
          printf("-"); 
      } 
 
      if(permission & S_IXOTH) 
      { 
          printf("x"); 
      } 
      else 
      { 
          printf("-"); 
      } 
 
      // Print the number of hard links 
      printf(" %d ", (int)st.st_nlink); 
 
      // Get the user name 
      struct passwd *pt = getpwuid(st.st_uid); 
      printf("%s ",pt->pw_name); 
 
      // Get the group name 
      struct group *p = getgrgid(st.st_gid); 
      printf("%s ",p->gr_name); 
 
      // Get the file size 
      printf("%lld ",(long long) st.st_size); 
 
      // Get the date and time 
      // Note that some logic is applied here 
      // so as to remove the trailing newline. 
      char date_time[100]; 
      memset(date_time,0,sizeof(date_time)); 
      strncpy(date_time, ctime(&st.st_ctime), sizeof(date_time)); 
      int c = 0; 
      while(date_time[c] != '\0') 
      { 
          if(date_time[c] == '\n') 
              date_time[c] = '\0'; 
          c++; 
      } 
      printf("%s ", date_time); 
 
       // Check if the file/folder is executable. 
      if(!access((const char*)ptr[count],X_OK)) 
      { 
          if(S_ISDIR(st.st_mode)) 
          { 
              // If folder, print in blue 
              printf("%s\n", (char*)ptr[count]); 
          } 
          else 
          {        
              // If executable file, print in green                            
              printf("%s\n", (char*)ptr[count]); 
          } 
      } 
      else 
      { 
          // If normal file, print by the default way(black color) 
          printf("%s\n",(char*)ptr[count]); 
      } 
      close(fd); 
   } 
 
   //Free the allocated memory 
   free(ptr); 
   return 0;     
}

int mx_no_flags(void) {
    char *curr_dir = NULL; 
    DIR *dp = NULL; 
    struct dirent *dptr = NULL; 
    unsigned int count = 0; 
    long *ptr = NULL; 
    struct winsize w; 
  
    //to get the number of rows and column visible on terminal 
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &w); 
       
    // Fetch the environment variable PWD so as to get the  
    // Current working directory 
    curr_dir = mx_getenv("PWD"); 

    if(NULL == curr_dir) 
    { 
        perror("\n ERROR : Could not get the working directory\n"); 
        return -1; 
    } 
 
    // Variable to hold number of files inside the directory 
    int num_files = 0; 
    // opne the directory 
    dp = opendir((const char*)curr_dir);   
    // Start reading the directory contents 
    while(NULL != (dptr = readdir(dp)))  
    { 
        // Do not count the files begining with '.' 
        if(dptr->d_name[0] != '.') 
        num_files++; 
    } 
    // Our aim was to count the number of files/folders  
    // inside the current working directory. Since its  
    // done so close the directory. 
    closedir(dp); 
  
    // Restore the values back as we will be using them 
    // later again 
    dp = NULL; 
    dptr = NULL; 
  
    // Check that we should have at least one file/folder 
    // inside the current working directory 
    if(!num_files) 
    { 
        return 0; 
    } 
    else 
    { 
        // Allocate memory to hold the addresses of the  
        // names of contents in current working directory 
        ptr = malloc(num_files*8); 
        if(NULL == ptr) 
        { 
            perror("\n Memory allocation failed\n"); 
            return -1; 
        } 
        else 
        { 
            // Initialize the memory by zeros 
            memset(ptr,0,num_files*8); 
        } 
    }  
  
    // Open the directory again 
    dp = opendir((const char*)curr_dir);    
    if(NULL == dp) 
    { 
        perror("\n ERROR : Could not open the working directory\n"); 
        free(ptr); 
        return -1; 
    } 
   
    // Start iterating the directory and read all its contents 
    // inside an array allocated above. 
    unsigned int j = 0; 
    for(count = 0; NULL != (dptr = readdir(dp)); count++) 
    { 
        if(dptr->d_name[0] != '.') 
        { 
           ptr[j] = (long)dptr->d_name; 
           j++;  
        } 
    } 
  
    // Start sorting the names alphabetically 
    // Using bubble sorting here 
    for(count = 0; count< num_files-1;count++) 
    { 
        for(j=count+1; j< (num_files);j++) 
        { 
            char *c = (char*)ptr[count]; 
            char *d = (char*)ptr[j]; 
             
            // Check that the two characters should be from same set 
            if( ((*c >= 65) && (*d >= 65)) || ((*c <=122) && (*d <=122)) ) 
            { 
                int i = 0; 
                // If initial characters are same, continue comparing 
                // the characters until a difference is found 
                if(*c == *d) 
                { 
                    while(*(c+i)==*(d+i)) 
                    { 
                        i++; 
                    } 
                } 
                // Check if the earlier stored value is alphabetically 
                // higher than the next value 
                if(*(c+i) > *(d+i)) 
                { 
                    // If yes, then swap the values 
                    long temp = 0; 
                    temp = ptr[count]; 
                    ptr[count] = ptr[j]; 
                    ptr[j] = temp; 
                } 
  
            } 
            else 
            { 
                // if the two beginning characters are not from 
                // the same ASCII set then make them same and then 
                // compare. 
                int off_1 = 0, off_2 = 0; 
                if(*c <= 90) 
                { 
                    off_1 = 32; 
                } 
                if(*d <= 90) 
                { 
                    off_2 = 32; 
                } 
  
                int i = 0; 
                // After the character set are made same, check if the 
                // beginning characters are same. If yes, then continue  
                // searching until we find some difference. 
                if(*c + off_1 == *d + off_2) 
                { 
                    while(*(c + off_1 + i)==*(d + off_2 + i)) 
                    { 
                        i++; 
                    } 
                } 
                // After difference is found, check if a swap is required. 
                if((*c + off_1 + i) > (*d + off_2 + i)) 
                { 
                    // If yes, go ahead and do the swap 
                    long temp = 0; 
                    temp = ptr[count]; 
                    ptr[count] = ptr[j]; 
                    ptr[j] = temp; 
                } 
            } 
        } 
     } 
  
    // Now the names are sorted alphabetically 
    // Start displaying on console. 
    for(count = 0; count< num_files; count++) 
    { 
        // Check if the file/folder is executable. 
        if(!file_exist((char*)ptr[count])) 
            { 
                int fd = -1; 
                struct stat st; 
  
                if (!opendir((char*)ptr[count])) 
                { 
                    perror("\n Opening file/Directory failed\n"); 
                    free(ptr); 
                    return -1; 
                } 
                 
                fstat(fd, &st); 
                if(S_ISDIR(st.st_mode)) 
                { 
                    write(1, (char*)ptr[count], strlen((char*)ptr[count])); // здесь нужно поменять на свою strlen
                    write(1, " ", 1);
                } 
                else 
                {        
                    // If executable file, print in green                            
                    write(1, (char*)ptr[count], strlen((char*)ptr[count])); // здесь нужно поменять на свою strlen
                    write(1, " ", 1);
                } 
                close(fd);
            } 
            else 
            { 
                write(1, (char*)ptr[count], strlen((char*)ptr[count])); // здесь нужно поменять на свою strlen
                write(1, " ", 1);
            } 
    } 
    write(1, "\n", 2); 
  
    //Free the allocated memory 
    free(ptr); 
    return 0; 
}

 int main(int argc, char *argv[]) 
 {  
    if (argc > 1) 
    {   
         //поменять на функцию сравнения строк
        if (strcmp(argv[1], "-l") == 0)     
            mx_flag_l();
    }
    else if (argc == 1) {
        mx_no_flags();
    }
   
 } 
 
